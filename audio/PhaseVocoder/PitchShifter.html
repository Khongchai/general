<!-- Interpolation-based phase vocoder -->

<!-- POC area before working on the real-time version -->

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div className="container">
      <label>Speed</label>
      <p id="current-rate"></p>
      <button data-playing="false" role="switch" aria-checked="false">
        <span>Play/Pause</span>
      </button>
      <button id="load-button">
        <span onclick="load()">Load</span>
      </button>
    </div>
    <canvas width="500" height="500" id="oscilloscope"></canvas>
  </body>
  <script>
    // Function to create a new stretched buffer
    /**
     * @param {AudioBuffer} audioBuffer
     * @param {number} rate
     * @param {"linear" | "cubic"} method
     */
    function shiftPitch(audioBuffer, rate, method) {
      const numChannels = audioBuffer.numberOfChannels;
      const oldLength = audioBuffer.length;
      const newLength = Math.floor(oldLength / rate);
      const newAudioBuffer = new AudioBuffer({
        length: newLength,
        sampleRate: audioBuffer.sampleRate,
        numberOfChannels: numChannels,
      });

      const maybeData = (float32Array, index) => {
        return float32Array[index] ?? 0;
      };

      if (method === "linear") {
        for (let channel = 0; channel < numChannels; channel++) {
          const source = audioBuffer.getChannelData(channel);
          const destination = newAudioBuffer.getChannelData(channel);

          for (let i = 0, rateAcc = 0; i < newLength; i++, rateAcc += rate) {
            const readIndex = Math.floor(rateAcc);
            const sample1 = source[readIndex];
            const sample2 = source[readIndex + 1] ?? 0;
            const interpolationFactor = rateAcc - readIndex;
            const sample =
              (1.0 - interpolationFactor) * sample1 +
              interpolationFactor * sample2;

            destination[i] = sample;
          }
        }
      } else {
        for (let channel = 0; channel < numChannels; channel++) {
          const oldChannelData = audioBuffer.getChannelData(channel);
          const newChannelData = newAudioBuffer.getChannelData(channel);

          let rateAcc = 0;
          for (
            let i = 2, rateAcc = rate * 2;
            i < newLength - 2;
            i++, rateAcc += rate
          ) {
            const interpolationPart = rateAcc;
            const sampleIndex = Math.floor(interpolationPart) + 1;
            const a = maybeData(oldChannelData, sampleIndex - 1);
            const b =
              (-11 * a) / 6 +
              3 * maybeData(oldChannelData, sampleIndex) -
              1.5 * maybeData(oldChannelData, sampleIndex + 1) +
              maybeData(oldChannelData, sampleIndex + 2) / 3;
            const c =
              a -
              2.5 * maybeData(oldChannelData, sampleIndex) +
              2 * maybeData(oldChannelData, sampleIndex + 1) -
              maybeData(oldChannelData, sampleIndex + 2) / 2;
            const d =
              -a / 6 +
              maybeData(oldChannelData, sampleIndex) / 2 -
              maybeData(oldChannelData, sampleIndex + 1) / 2 +
              maybeData(oldChannelData, sampleIndex + 2) / 6;
            // range of xInterpolation = [1, 2]
            const xInterpolation = interpolationPart - sampleIndex + 2;
            newChannelData[i] =
              a +
              b * xInterpolation +
              c * xInterpolation ** 2 +
              d * xInterpolation ** 3;
          }
        }
      }

      return newAudioBuffer;
    }
  </script>
  <script>
    /** @type {Uint8Array} */
    let scratchBytes;
    async function main() {
      const audioContext = new AudioContext({
        sampleRate: 44_100,
      });

      const audioElement = document.querySelector("audio");
      const playButton = document.querySelector("button");
      let currentRate = 1;
      const rateElem = document.getElementById("current-rate");
      rateElem.innerHTML = String(currentRate);

      if (playButton === null || rateElem === null) {
        throw new Error("Some elements were not found");
      }

      const files = [
        "../tchai-short.wav", // 0
        "../a.wav", // 1
        "../c2.wav", // 2
        "../c3.wav", // 3
        "../c7.wav", // 4
      ];
      /**
       * @type {ArrayBuffer}
       */
      const audioData = await fetch(files[1]).then((response) =>
        response.arrayBuffer(),
      );

      const uint8array = new Uint8Array(audioData);

      const oldBuffer = await audioContext.decodeAudioData(audioData);
      const audioBuffer = shiftPitch(oldBuffer, currentRate, "cubic");

      const source = audioContext.createBufferSource();

      const analyzer = audioContext.createAnalyser();
      analyzer.fftSize = 2048;
      const bufferLength = analyzer.frequencyBinCount;
      scratchBytes = new Uint8Array(bufferLength);

      source.buffer = audioBuffer;
      source.connect(analyzer).connect(audioContext.destination);
      source.loop = true; // Enable looping

      playButton.addEventListener("click", function () {
        if (this.dataset.playing === "false") {
          source.start(0);
          this.dataset.playing = "true";
        } else {
          source.stop(0);
          this.dataset.playing = "false";
        }
      });

      return analyzer;
    }

    function initCanvas(analyzer) {
      const canvas = document.getElementById("oscilloscope");
      const HEIGHT = 500;
      const WIDTH = window.innerWidth;
      canvas.height = HEIGHT * devicePixelRatio;
      canvas.width = WIDTH * devicePixelRatio;
      const ctx = canvas.getContext("2d");

      function osc() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        analyzer.getByteTimeDomainData(scratchBytes);

        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.lineWidth = 2;
        ctx.strokeStyle = "white";
        ctx.beginPath();

        const bufferLength = scratchBytes.byteLength;
        const sliceWidth = canvas.width / bufferLength;
        let x = 0;

        const gain = 1;
        for (let i = 0; i < bufferLength; i++) {
          let v = scratchBytes[i] / 128.0; // 0 to 1
          let y = (v * canvas.height) / 2;

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }

          x += sliceWidth;
        }

        ctx.lineTo(canvas.width, canvas.height / 2);
        ctx.stroke();

        setTimeout(osc, 128);
      }

      osc();
    }

    // TODO draw spectogram
    function spectogram() {}

    /**
     * To force user interaction for audio context
     */
    async function load() {
      const analyzer = await main();
      initCanvas(analyzer);
      const loadButton = document.getElementById("load-button");
      if (!loadButton) {
        throw new Error("Load button could not be found");
      }

      loadButton.innerHTML = "Loaded";
    }
  </script>
</html>
