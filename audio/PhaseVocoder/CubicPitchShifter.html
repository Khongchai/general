<!-- Interpolation-based phase vocoder -->

<!-- POC area before working on the real-time version -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div className="container">
      <label>Speed</label>
      <p id="current-rate"></p>
    </div>
    <button data-playing="false" role="switch" aria-checked="false">
      <span>Play/Pause</span>
    </button>
    <button id="load-button">
      <span onclick="load()">Load</span>
    </button>
  </body>
  <script>
    // Function to create a new stretched buffer
    /**
     * @param {AudioBuffer} audioBuffer
     * @param {number} rate
     */
    function shiftPitch(audioBuffer, rate) {
      const numChannels = audioBuffer.numberOfChannels;
      const oldLength = audioBuffer.length;
      const newLength = Math.floor(oldLength / rate);
      const newAudioBuffer = new AudioBuffer({
        length: newLength,
        sampleRate: audioBuffer.sampleRate,
        numberOfChannels: numChannels,
      });

      const maybeData = (float32Array, index) => {
        return float32Array[index] ?? 0;
      };

      // Loop through each channel
      for (let channel = 0; channel < numChannels; channel++) {
        const oldChannelData = audioBuffer.getChannelData(channel);
        const newChannelData = newAudioBuffer.getChannelData(channel);

        // Fill the stretched buffer
        let rateAcc = 0;
        for (
          let i = 2, rateAcc = rate * 2;
          i < newLength - 2;
          i++, rateAcc += rate
        ) {
          const interpolationPart = rateAcc;
          const sampleIndex = Math.floor(interpolationPart) + 1;
          const a = maybeData(oldChannelData, sampleIndex - 1);
          const b =
            (-11 * a) / 6 +
            3 * maybeData(oldChannelData, sampleIndex) -
            1.5 * maybeData(oldChannelData, sampleIndex + 1) +
            maybeData(oldChannelData, sampleIndex + 2) / 3;
          const c =
            a -
            2.5 * maybeData(oldChannelData, sampleIndex) +
            2 * maybeData(oldChannelData, sampleIndex + 1) -
            maybeData(oldChannelData, sampleIndex + 2) / 2;
          const d =
            -a / 6 +
            maybeData(oldChannelData, sampleIndex) / 2 -
            maybeData(oldChannelData, sampleIndex + 1) / 2 +
            maybeData(oldChannelData, sampleIndex + 2) / 6;
          const xInterpolation = interpolationPart - sampleIndex + 2;
          newChannelData[i] =
            a +
            b * xInterpolation +
            c * xInterpolation ** 2 +
            d * xInterpolation ** 3;
        }
      }

      return newAudioBuffer;
    }
  </script>
  <script>
    // @ts-check

    async function main() {
      const audioContext = new AudioContext({
        sampleRate: 44_100,
      });

      const audioElement = document.querySelector("audio");
      const playButton = document.querySelector("button");
      let currentRate = 0.85;
      const rateElem = document.getElementById("current-rate");
      rateElem.innerHTML = String(currentRate);

      if (playButton === null || rateElem === null) {
        throw new Error("Some elements were not found");
      }

      /**
       * @type {ArrayBuffer}
       */
      const audioData = await fetch("../tchai-short.wav").then((response) =>
        response.arrayBuffer()
      );

      const uint8array = new Uint8Array(audioData);

      const oldBuffer = await audioContext.decodeAudioData(audioData);
      const audioBuffer = shiftPitch(oldBuffer, currentRate);

      const source = audioContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(audioContext.destination);

      playButton.addEventListener("click", function () {
        if (this.dataset.playing === "false") {
          source.start(0);
          this.dataset.playing = "true";
        } else {
          source.stop(0);
          this.dataset.playing = "false";
        }
      });
    }

    /**
     * To force user interaction for audio context
     */
    function load() {
      main();
      const loadButton = document.getElementById("load-button");
      if (!loadButton) {
        throw new Error("Load button could not be found");
      }

      loadButton.innerHTML = "Loaded";
    }
  </script>
</html>
