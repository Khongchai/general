<!-- Interpolation-based phase vocoder -->

<!-- status: everything now works except the first hanning window -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div className="container">
      <label>Speed</label>
      <input
        type="range"
        id="speed"
        min="0.2"
        max="1.5"
        value="1"
        step="0.01"
      />
    </div>
    <button data-playing="false" role="switch" aria-checked="false">
      <span>Play/Pause</span>
    </button>
  </body>

  <script>
    // @ts-check

    /**
     * @param {number} N;
     * @returns {Float32Array}
     */
    const getHanningWindow = (N) => {
      const window = new Float32Array(N);
      for (let n = 0; n < N; n++) {
        window[n] = 0.5 * (1 - Math.cos((2 * Math.PI * n) / (N - 1)));
      }
      return window;
    };
    /**
     * @param {number} x
     * @param {number} y
     */
    function mag(x, y) {
      return Math.sqrt(x * x + y * y);
    }

    /**
     * @param {number} r
     */
    function shift(r) {
      while (r >= Math.PI) r -= 2 * Math.PI;
      while (r < -Math.PI) r += 2 * Math.PI;
      return r;
    }

    /**
     * @param {number} currentFramePos
     * @param {Float32Array} nextFrame
     * @param {Float32Array} input
     * @param {Float32Array} outputs
     * @param {number} outputOffset
     * @param {number} frameSize
     * @param {Float32Array} phaseAccumulator
     * @param {Float32Array} hanning
     * @param {number} hopSize
     */
    function interpolateFramesTo(
      currentFramePos,
      nextFrame,
      input,
      outputs,
      outputOffset,
      frameSize,
      phaseAccumulator,
      hanning,
      hopSize
    ) {
      if (nextFrame.length !== frameSize) {
        return;
      }

      const newInput = new Float32Array(frameSize);
      const newNextFrame = new Float32Array(frameSize);
      for (let i = 0; i < frameSize; i++) {
        newInput[i] = input[i] * hanning[i];
        newNextFrame[i] = nextFrame[i] * hanning[i];
      }

      const currentFreq = fft(newInput);
      const nextFreq = fft(newNextFrame);
      const outputFreq = {
        real: new Float32Array(frameSize),
        imag: new Float32Array(frameSize),
      };

      const nextFrameAlpha = currentFramePos - Math.floor(currentFramePos);
      const currentFrameAlpha = 1 - nextFrameAlpha;

      for (let i = 0; i < frameSize / 2; i++) {
        // take care of overlap add first!
        const magnitude =
          currentFrameAlpha * mag(currentFreq.real[i], currentFreq.imag[i]) +
          nextFrameAlpha * mag(nextFreq.real[i], nextFreq.imag[i]);
        const phaseAlpha = shift(
          Math.atan2(nextFreq.imag[i], nextFreq.real[i]) -
            Math.atan2(currentFreq.imag[i], currentFreq.real[i])
        );
        outputFreq.real[i] = magnitude * Math.cos(phaseAccumulator[i]);
        outputFreq.imag[i] = magnitude * Math.sin(phaseAccumulator[i]);
        phaseAccumulator[i] = phaseAccumulator[i] + phaseAlpha;
        // uncomment to copy straight from input to output
        // outputFreq.real[i] = currentFreq.real[i];
        // outputFreq.imag[i] = currentFreq.imag[i];
      }

      // mirror the negative frequencies
      for (let i = frameSize / 2 + 1; i < frameSize; i++) {
        outputFreq.real[i] = outputFreq.real[frameSize - i];
        outputFreq.imag[i] = -outputFreq.imag[frameSize - i];
      }

      // ifft

      const outputTime = new Float32Array(ifft(outputFreq));

      for (let i = 0; i < frameSize; i++) {
        if (i < frameSize - hopSize) {
          outputs[outputOffset + i] += outputTime[i] * hanning[i];
        } else {
          outputs[outputOffset + i] = outputTime[i] * hanning[i];
        }
      }
    }

    /**
     * @param {Float32Array} inputs
     * @param {Float32Array} outputs
     * @param {number} ratio
     *
     * No optimizations done. This is just so that the code is readable.
     *
     * In the end, when ratio is not one, outputs array will be longer.
     *
     * inputs is the full audio buffer. outputs is initialized to be 2 times the size of inputs in case of 0.5 speed. So don't go lower.
     */
    function resampleChannel(inputs, outputs, ratio) {
      console.log("Start");
      const frameSize = 2048;
      // 75% overlap
      const hopSize = Math.floor(frameSize * 0.25); // 512
      const hanning = getHanningWindow(frameSize);
      const halfLength = frameSize / 2;

      const totalFrameCount = Math.floor(inputs.length / hopSize);

      let previousFrame = inputs.subarray(0, frameSize);
      const prevFrameOut = new Float32Array(frameSize);
      const phaseAccumulator = new Float32Array(halfLength);
      for (let i = 0; i < hanning.length; i++) {
        prevFrameOut[i] = previousFrame[i] * hanning[i];
      }
      const fftPrev = fft(prevFrameOut);
      for (let i = 0; i < halfLength; i++) {
        phaseAccumulator[i] = Math.atan2(fftPrev.imag[i], fftPrev.real[i]);
      }

      for (
        let currentFramePos = 0, outputOffset = 0;
        currentFramePos < totalFrameCount;
        // ratio is the frame position
        // this is the only place that uses ratio
        currentFramePos = currentFramePos + ratio, outputOffset += hopSize
      ) {
        const currentFrameFloored = Math.floor(currentFramePos);

        // input and nextFrame has an overlap of 75% (only the last of next frame is not an overlap)

        const input = inputs.subarray(
          currentFrameFloored * hopSize,
          currentFrameFloored * hopSize + frameSize
        );

        const nextFrame = inputs.subarray(
          (currentFrameFloored + 1) * hopSize,
          (currentFrameFloored + 1) * hopSize + frameSize
        );

        interpolateFramesTo(
          currentFramePos,
          nextFrame,
          input,
          outputs,
          outputOffset,
          frameSize,
          phaseAccumulator,
          hanning,
          hopSize
        );
      }

      console.log("Done");
    }
  </script>
  <script>
    // Function to create a new stretched buffer
    /**
     * @param {AudioBuffer} audioBuffer
     * @param {number} playbackRate
     */
    function stretchAudioBuffer(audioBuffer, playbackRate) {
      const numChannels = audioBuffer.numberOfChannels;
      const oldLength = audioBuffer.length;
      const newLength = Math.floor(oldLength / playbackRate);
      const newAudioBuffer = new AudioBuffer({
        length: newLength,
        sampleRate: audioBuffer.sampleRate,
        numberOfChannels: numChannels,
      });

      // Loop through each channel
      for (let channel = 0; channel < numChannels; channel++) {
        const oldChannelData = audioBuffer.getChannelData(channel);
        const newChannelData = newAudioBuffer.getChannelData(channel);

        // Fill the stretched buffer
        for (let i = 0; i < newLength; i++) {
          newChannelData[i] = oldChannelData[Math.floor(i)] ?? 0;
        }
      }

      return newAudioBuffer;
    }
  </script>
  <script>
    // @ts-check

    let playbackRate = 0.8;

    async function main() {
      const audioContext = new AudioContext();

      const audioElement = document.querySelector("audio");
      const playButton = document.querySelector("button");
      const speedControl = document.querySelector("#speed");

      if (playButton === null || speedControl === null) {
        throw new Error("Some elements were not found");
      }

      /**
       * @type {ArrayBuffer}
       */
      const audioData = await fetch("tchai-short.wav").then((response) =>
        response.arrayBuffer()
      );

      const oldBuffer = await audioContext.decodeAudioData(audioData);
      const audioBuffer = stretchAudioBuffer(oldBuffer, playbackRate);

      for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
        const channelData = audioBuffer.getChannelData(i);
        const out = new Float32Array(channelData.length * 5);
        resampleChannel(channelData, out, playbackRate);
        audioBuffer.copyToChannel(out, i);
      }

      const source = audioContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(audioContext.destination);

      playButton.addEventListener("click", function () {
        if (this.dataset.playing === "false") {
          source.start(0);
          this.dataset.playing = "true";
        } else {
          source.stop(0);
          this.dataset.playing = "false";
        }
      });
    }

    main();
  </script>
  <script>
    "use strict";

    // memoization of the reversal of different lengths.
    var memoizedReversal = {};
    var memoizedZeroBuffers = {};

    let constructComplexArray = function (signal) {
      var complexSignal = {};

      complexSignal.real =
        signal.real === undefined ? signal.slice() : signal.real.slice();

      var bufferSize = complexSignal.real.length;

      if (memoizedZeroBuffers[bufferSize] === undefined) {
        memoizedZeroBuffers[bufferSize] = Array.apply(
          null,
          Array(bufferSize)
        ).map(Number.prototype.valueOf, 0);
      }

      complexSignal.imag = memoizedZeroBuffers[bufferSize].slice();

      return complexSignal;
    };

    let bitReverseArray = function (N) {
      if (memoizedReversal[N] === undefined) {
        let maxBinaryLength = (N - 1).toString(2).length; //get the binary length of the largest index.
        let templateBinary = "0".repeat(maxBinaryLength); //create a template binary of that length.
        let reversed = {};
        for (let n = 0; n < N; n++) {
          let currBinary = n.toString(2); //get binary value of current index.

          //prepend zeros from template to current binary. This makes binary values of all indices have the same length.
          currBinary = templateBinary.substr(currBinary.length) + currBinary;

          currBinary = [...currBinary].reverse().join(""); //reverse
          reversed[n] = parseInt(currBinary, 2); //convert to decimal
        }
        memoizedReversal[N] = reversed; //save
      }
      return memoizedReversal[N];
    };

    // complex multiplication
    let multiply = function (a, b) {
      return {
        real: a.real * b.real - a.imag * b.imag,
        imag: a.real * b.imag + a.imag * b.real,
      };
    };

    // complex addition
    let add = function (a, b) {
      return {
        real: a.real + b.real,
        imag: a.imag + b.imag,
      };
    };

    // complex subtraction
    let subtract = function (a, b) {
      return {
        real: a.real - b.real,
        imag: a.imag - b.imag,
      };
    };

    // euler's identity e^x = cos(x) + sin(x)
    let euler = function (kn, N) {
      let x = (-2 * Math.PI * kn) / N;
      return { real: Math.cos(x), imag: Math.sin(x) };
    };

    // complex conjugate
    let conj = function (a) {
      a.imag *= -1;
      return a;
    };

    /**
     * @param {Float32Array | {real?: Float32Array, imag?: Float32Array}} signal
     * @returns {{real: Float32Array, imag: Float32Array}}
     */
    function fft(signal) {
      let complexSignal = {};

      // @ts-ignore
      if (signal.real === undefined || signal.imag === undefined) {
        complexSignal = constructComplexArray(signal);
      } else {
        // @ts-ignore
        complexSignal.real = signal.real.slice();
        // @ts-ignore
        complexSignal.imag = signal.imag.slice();
      }

      const N = complexSignal.real.length;
      const logN = Math.log2(N);

      if (Math.round(logN) != logN)
        throw new Error("Input size must be a power of 2.");

      if (complexSignal.real.length != complexSignal.imag.length) {
        throw new Error(
          "Real and imaginary components must have the same length."
        );
      }

      const bitReversedIndices = bitReverseArray(N);

      // sort array
      let ordered = {
        real: [],
        imag: [],
      };

      for (let i = 0; i < N; i++) {
        // @ts-ignore
        ordered.real[bitReversedIndices[i]] = complexSignal.real[i];
        // @ts-ignore
        ordered.imag[bitReversedIndices[i]] = complexSignal.imag[i];
      }

      for (let i = 0; i < N; i++) {
        complexSignal.real[i] = ordered.real[i];
        complexSignal.imag[i] = ordered.imag[i];
      }
      // iterate over the number of stages
      for (let n = 1; n <= logN; n++) {
        let currN = Math.pow(2, n);

        // find twiddle factors
        for (let k = 0; k < currN / 2; k++) {
          let twiddle = euler(k, currN);

          // on each block of FT, implement the butterfly diagram
          for (let m = 0; m < N / currN; m++) {
            let currEvenIndex = currN * m + k;
            let currOddIndex = currN * m + k + currN / 2;

            let currEvenIndexSample = {
              real: complexSignal.real[currEvenIndex],
              imag: complexSignal.imag[currEvenIndex],
            };
            let currOddIndexSample = {
              real: complexSignal.real[currOddIndex],
              imag: complexSignal.imag[currOddIndex],
            };

            let odd = multiply(twiddle, currOddIndexSample);

            let subtractionResult = subtract(currEvenIndexSample, odd);
            complexSignal.real[currOddIndex] = subtractionResult.real;
            complexSignal.imag[currOddIndex] = subtractionResult.imag;

            let additionResult = add(odd, currEvenIndexSample);
            complexSignal.real[currEvenIndex] = additionResult.real;
            complexSignal.imag[currEvenIndex] = additionResult.imag;
          }
        }
      }

      return complexSignal;
    }

    // complex to real ifft
    /**
     * @returns {number[]}
     */
    function ifft(signal) {
      if (signal.real === undefined || signal.imag === undefined) {
        throw new Error("IFFT only accepts a complex input.");
      }

      const N = signal.real.length;

      var complexSignal = {
        real: [],
        imag: [],
      };

      //take complex conjugate in order to be able to use the regular FFT for IFFT
      for (let i = 0; i < N; i++) {
        let currentSample = {
          real: signal.real[i],
          imag: signal.imag[i],
        };

        let conjugateSample = conj(currentSample);
        // @ts-ignore
        complexSignal.real[i] = conjugateSample.real;
        // @ts-ignore
        complexSignal.imag[i] = conjugateSample.imag;
      }

      //compute
      // @ts-ignore
      let X = fft(complexSignal);

      //normalize
      // @ts-ignore
      complexSignal.real = X.real.map((val) => {
        return val / N;
      });

      // @ts-ignore
      complexSignal.imag = X.imag.map((val) => {
        return val / N;
      });

      // @ts-ignore
      return complexSignal.real;
    }
  </script>
</html>
